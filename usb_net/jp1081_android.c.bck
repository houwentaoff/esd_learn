/*************************************************************************
	> File Name: jp1081_android.c
	> Author: shuixianbing
	> Mail: shui6666@126.com 
	> Created Time: 2014年10月21日 星期二 15时50分09秒
 ************************************************************************/
#include <linux/init.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/stddef.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/ethtool.h>
#include <linux/mii.h>
#include <linux/usb.h>
#include <linux/crc32.h>
#include <linux/usb/usbnet.h>
#include <linux/delay.h>
#include "jp1081_android.h"

MODULE_LICENSE("GPL");
//jp1081_android read some registers from MAC
static int qf_read(struct usbnet *dev, u8 reg, u16 length, void *data){
	void *buf;
	int err = -ENOMEM;
	printk("qf_read() reg=0x%02x length=%d", reg, length);
	buf = kmalloc(length, GFP_KERNEL);

	if(!buf)
		goto out;

	err = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
			QF_RD_REGS, QF_REQ_RD_REG,
			0, reg, buf, length, USB_CTRL_SET_TIMEOUT);
	if(err == length)
		memcpy(data, buf, length);
	else if(err >= 0)
		err = -EINVAL;
	kfree(buf);
out:
	return err;
}
//jp1081_android write some registers to MAC
static int qf_write(struct usbnet *dev, u8 reg, u16 length, void *data){
	void *buf = NULL;
	int err = -ENOMEM;
	printk("qf_write() reg=0x%02x, length=%d", reg, length);

	if(data){
		buf = kmalloc(length, GFP_KERNEL);
		if(!buf)
			goto out;
		memcpy(buf, data, length);
	}

	err = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			QF_WR_REGS, QF_REQ_WR_REG,
			0, reg, buf, length, USB_CTRL_SET_TIMEOUT);
	kfree(buf);
	if(err >=0 && err < length)
		err = -EINVAL;

out:
	return err;
}

//jp1081_android read one register from MAC
static int qf_read_reg(struct usbnet *dev, u8 reg, u8 *value){
	return qf_read(dev, reg, 1, value);
}
//jp1081_android write one register to MAC
static int qf_write_reg(struct usbnet *dev, u8 reg, u8 value){
	printk("qf_write_reg() reg=0x%2x, value=0x%02x", reg, value);

	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			QF_WR_REG, QF_REQ_WR_REG,
			value, reg, NULL, 0, USB_CTRL_SET_TIMEOUT);
}
//jp1081_android read one word from phy or eeprom
static int qf_share_read_word(struct usbnet *dev, int phy, u8 reg, __le16 *value){
	int ret, i;
	mutex_lock(&dev->phy_mutex);

	qf_write_reg(dev, EPAR, phy ? (reg | 0x40) : reg);
	qf_write_reg(dev, EPCR, phy ? 0xc : 0x4);

	for(i=0; i<QF_SHARE_TIMEOUT;i++){
		u8 tmp;
		udelay(1);
		ret = qf_read_reg(dev, EPCR, &tmp);
		if(ret < 0)
			goto out;

		//ready
		if((tmp & 1) == 0)
			break;
	}
	if(i>= QF_SHARE_TIMEOUT){
		printk("%s read timed out!", phy ? "phy" : "eeprom");
		ret = -EIO;
		goto out;
	}

	qf_write_reg(dev, EPCR, 0x0);
	ret = qf_read(dev, EPDR, 2, value);

	printk("read shared %d 0x%02x returned 0x%04x, %d",
			phy, reg, *value, ret);

out:
	mutex_unlock(&dev->phy_mutex);
	return ret;
}

//write one word to phy 
static int qf_share_write_word(struct usbnet *dev, int phy, u8 reg, __le16 value){
	int ret, i;
	mutex_lock(&dev->phy_mutex);
	ret = qf_write(dev, EPDR, 2, &value);
	if(ret < 0)
		goto out;

	qf_write_reg(dev, EPAR, phy ? (reg | 0x40): reg);
	qf_write_reg(dev, EPCR, phy ? 0x1a : 0x12);

	for(i=0; i<QF_SHARE_TIMEOUT;i++){
		u8 tmp;
		udelay(1);
		ret = qf_read_reg(dev, EPCR, &tmp);
		if(ret < 0){
			goto out;
		}
		//ready
		if((tmp & 1)==0)
			break;
	}
	if(i>=QF_SHARE_TIMEOUT){
		printk("%s write timed out", phy ? "phy" : "eeprom");
		ret = -EIO;
		goto out;
	}

	qf_write_reg(dev, EPCR, 0x0);
out:
	mutex_unlock(&dev->phy_mutex);
	return ret;
}
//jp1081_android mii-phy register read by word
static int jp1081_android_mdio_read(struct net_device *netdev, int phy_id, int loc){
	struct usbnet *dev = netdev_priv(netdev);

	__le16 res;

	if(phy_id){
		printk("Only internal phy supported");
		return 0;
	}

	qf_share_read_word(dev, 1, loc, &res);
	printk("jp1081_android_mdio_read() phy_id=0x%02x, loc=0x%02x,returns=0x%04x", phy_id, loc, le16_to_cpu(res));

	return le16_to_cpu(res);
}

//jp1081_android mii-phy register write by word
static void jp1081_android_mdio_write(struct net_device *netdev, int phy_id,
int loc, int val){
	struct usbnet *dev = netdev_priv(netdev);
	__le16 res = cpu_to_le16(val);
	if(phy_id){
		printk("only internal phy supported");
		return;
	}
	printk("jp1081_android_mdio_write() phy_id=0x%02x, loc=0x%02x, returns=0x%04x", phy_id, loc, val);

	qf_share_write_word(dev, 1, loc, res);
}

static void jp1081_android_set_multicast(struct net_device *net){
	
}
static int jp1081_android_bind(struct usbnet *dev, struct usb_interface *intf){
	int ret;

	ret = usbnet_get_endpoints(dev, intf);
	if(ret){
		goto out;
	}

	dev->net->hard_header_len += QF_TX_OVERHEAD;
	dev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;
	dev->rx_urb_size = dev->net->mtu + ETH_HLEN + QF_RX_OVERHEAD;

	dev->mii.dev = dev->net;
	dev->mii.mdio_read = jp1081_android_mdio_read;
	dev->mii.mdio_write = jp1081_android_mdio_write;
	dev->mii.phy_id_mask = 0x1f;
	dev->mii.reg_num_mask = 0x1f;

	//reset the jp1081 android
	qf_write_reg(dev, NCR, 1);
	udelay(20);
	//read MAC
	if(qf_read(dev, PAR, ETH_ALEN, dev->net->dev_addr) < 0){
		printk("Error reading MAC address\n");
		ret = -ENODEV;
		goto out;
	}

	//power up and reset phy
	qf_write_reg(dev, PRR, 1);
	mdelay(20);

	qf_write_reg(dev, PRR, 0);
	udelay(2*1000);

	//receive brodcast packets
	jp1081_android_set_multicast(dev->net);

	jp1081_android_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
	jp1081_android_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE, ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
	mii_nway_restart(&dev->mii);

out:
	return ret;
}

static const struct driver_info jp1081_android_info = {
	.description = "JP1081_ANDROID USB Ethernet",
	.flags = FLAG_ETHER,
	.bind = jp1081_android_bind,
};

static const struct usb_device_id products[] = {
	{
		USB_DEVICE(0x0fe6, 0x9700),
		.driver_info = (unsigned long)&jp1081_android_info,
	},
	{},
};

MODULE_DEVICE_TABLE(usb, products);

static struct usb_driver jp1081_android_driver = {
	.name = "jp1081_android",
	.id_table = products,
	.probe = usbnet_probe,
	.disconnect = usbnet_disconnect,
	.suspend = usbnet_suspend,
	.resume = usbnet_resume,
};

static int __init jp1081_android_init(void){
	
	return usb_register(&jp1081_android_driver);
}

static void __exit jp1081_android_exit(void){
	usb_deregister(&jp1081_android_driver);
}
module_init(jp1081_android_init);
module_exit(jp1081_android_exit);
